// Code generated by ObjectBox; DO NOT EDIT.
// Learn more about defining entities and generating this file - visit https://golang.objectbox.io/entity-annotations

package schema

import (
	"errors"
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

type card_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var CardBinding = card_EntityInfo{
	Entity: objectbox.Entity{
		Id: 1,
	},
	Uid: 1728523190254749745,
}

// Card_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Card_ = struct {
	Id     *objectbox.PropertyUint64
	Data   *objectbox.PropertyString
	CardId *objectbox.PropertyString
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &CardBinding.Entity,
		},
	},
	Data: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &CardBinding.Entity,
		},
	},
	CardId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &CardBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (card_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (card_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Card", 1, 1728523190254749745)
	model.Property("Id", 6, 1, 8544395346678812316)
	model.PropertyFlags(1)
	model.Property("Data", 9, 2, 8184353917683228508)
	model.Property("CardId", 9, 3, 2601013580858766931)
	model.EntityLastPropertyId(4, 5847503720074439249)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (card_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Card).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (card_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Card).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (card_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (card_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Card)
	var offsetData = fbutils.CreateStringOffset(fbb, obj.Data)
	var offsetCardId = fbutils.CreateStringOffset(fbb, obj.CardId)

	// build the FlatBuffers object
	fbb.StartObject(4)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetData)
	fbutils.SetUOffsetTSlot(fbb, 2, offsetCardId)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (card_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Card' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	return &Card{
		Id:     propId,
		Data:   fbutils.GetStringSlot(table, 6),
		CardId: fbutils.GetStringSlot(table, 8),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (card_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Card, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (card_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Card), nil)
	}
	return append(slice.([]*Card), object.(*Card))
}

// Box provides CRUD access to Card objects
type CardBox struct {
	*objectbox.Box
}

// BoxForCard opens a box of Card objects
func BoxForCard(ob *objectbox.ObjectBox) *CardBox {
	return &CardBox{
		Box: ob.InternalBox(1),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Card.Id property on the passed object will be assigned the new ID as well.
func (box *CardBox) Put(object *Card) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Card.Id property on the passed object will be assigned the new ID as well.
func (box *CardBox) Insert(object *Card) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *CardBox) Update(object *Card) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *CardBox) PutAsync(object *Card) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Card.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Card.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *CardBox) PutMany(objects []*Card) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *CardBox) Get(id uint64) (*Card, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Card), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *CardBox) GetMany(ids ...uint64) ([]*Card, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Card), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *CardBox) GetManyExisting(ids ...uint64) ([]*Card, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Card), nil
}

// GetAll reads all stored objects
func (box *CardBox) GetAll() ([]*Card, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Card), nil
}

// Remove deletes a single object
func (box *CardBox) Remove(object *Card) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *CardBox) RemoveMany(objects ...*Card) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Card_ struct to create conditions.
// Keep the *CardQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *CardBox) Query(conditions ...objectbox.Condition) *CardQuery {
	return &CardQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Card_ struct to create conditions.
// Keep the *CardQuery if you intend to execute the query multiple times.
func (box *CardBox) QueryOrError(conditions ...objectbox.Condition) (*CardQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &CardQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See CardAsyncBox for more information.
func (box *CardBox) Async() *CardAsyncBox {
	return &CardAsyncBox{AsyncBox: box.Box.Async()}
}

// CardAsyncBox provides asynchronous operations on Card objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type CardAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForCard creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use CardBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForCard(ob *objectbox.ObjectBox, timeoutMs uint64) *CardAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 1, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 1: %s" + err.Error())
	}
	return &CardAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *CardAsyncBox) Put(object *Card) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *CardAsyncBox) Insert(object *Card) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *CardAsyncBox) Update(object *Card) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *CardAsyncBox) Remove(object *Card) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Card which Id is either 42 or 47:
//
// box.Query(Card_.Id.In(42, 47)).Find()
type CardQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *CardQuery) Find() ([]*Card, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Card), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *CardQuery) Offset(offset uint64) *CardQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *CardQuery) Limit(limit uint64) *CardQuery {
	query.Query.Limit(limit)
	return query
}

type draft_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var DraftBinding = draft_EntityInfo{
	Entity: objectbox.Entity{
		Id: 2,
	},
	Uid: 5663264790156429323,
}

// Draft_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Draft_ = struct {
	Id                 *objectbox.PropertyUint64
	Name               *objectbox.PropertyString
	Format             *objectbox.PropertyString
	InPerson           *objectbox.PropertyBool
	SpectatorChannelId *objectbox.PropertyString
	Seats              *objectbox.RelationToMany
	UnassignedPacks    *objectbox.RelationToMany
	Events             *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &DraftBinding.Entity,
		},
	},
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &DraftBinding.Entity,
		},
	},
	Format: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &DraftBinding.Entity,
		},
	},
	InPerson: &objectbox.PropertyBool{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &DraftBinding.Entity,
		},
	},
	SpectatorChannelId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     5,
			Entity: &DraftBinding.Entity,
		},
	},
	Seats: &objectbox.RelationToMany{
		Id:     1,
		Source: &DraftBinding.Entity,
		Target: &SeatBinding.Entity,
	},
	UnassignedPacks: &objectbox.RelationToMany{
		Id:     2,
		Source: &DraftBinding.Entity,
		Target: &PackBinding.Entity,
	},
	Events: &objectbox.RelationToMany{
		Id:     8,
		Source: &DraftBinding.Entity,
		Target: &EventBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (draft_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (draft_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Draft", 2, 5663264790156429323)
	model.Property("Id", 6, 1, 8858029890058417170)
	model.PropertyFlags(1)
	model.Property("Name", 9, 2, 4508250143033471113)
	model.Property("Format", 9, 3, 268971421038837113)
	model.Property("InPerson", 1, 4, 7606563587574782325)
	model.Property("SpectatorChannelId", 9, 5, 7498775565443963097)
	model.PropertyFlags(2048)
	model.PropertyIndex(15, 722712850427169033)
	model.EntityLastPropertyId(5, 7498775565443963097)
	model.Relation(1, 751382817597970823, SeatBinding.Id, SeatBinding.Uid)
	model.Relation(2, 5954888830735860335, PackBinding.Id, PackBinding.Uid)
	model.Relation(8, 3916323228265520547, EventBinding.Id, EventBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (draft_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Draft).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (draft_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Draft).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (draft_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if err := BoxForDraft(ob).RelationReplace(Draft_.Seats, id, object, object.(*Draft).Seats); err != nil {
		return err
	}

	if err := BoxForDraft(ob).RelationReplace(Draft_.UnassignedPacks, id, object, object.(*Draft).UnassignedPacks); err != nil {
		return err
	}

	if err := BoxForDraft(ob).RelationReplace(Draft_.Events, id, object, object.(*Draft).Events); err != nil {
		return err
	}

	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (draft_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Draft)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)
	var offsetFormat = fbutils.CreateStringOffset(fbb, obj.Format)
	var offsetSpectatorChannelId = fbutils.CreateStringOffset(fbb, obj.SpectatorChannelId)

	// build the FlatBuffers object
	fbb.StartObject(5)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetName)
	fbutils.SetUOffsetTSlot(fbb, 2, offsetFormat)
	fbutils.SetBoolSlot(fbb, 3, obj.InPerson)
	fbutils.SetUOffsetTSlot(fbb, 4, offsetSpectatorChannelId)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (draft_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Draft' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relSeats []*Seat
	if rIds, err := BoxForDraft(ob).RelationIds(Draft_.Seats, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForSeat(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relSeats = rSlice
	}

	var relUnassignedPacks []*Pack
	if rIds, err := BoxForDraft(ob).RelationIds(Draft_.UnassignedPacks, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForPack(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relUnassignedPacks = rSlice
	}

	var relEvents []*Event
	if rIds, err := BoxForDraft(ob).RelationIds(Draft_.Events, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForEvent(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relEvents = rSlice
	}

	return &Draft{
		Id:                 propId,
		Name:               fbutils.GetStringSlot(table, 6),
		Format:             fbutils.GetStringSlot(table, 8),
		InPerson:           fbutils.GetBoolSlot(table, 10),
		Seats:              relSeats,
		UnassignedPacks:    relUnassignedPacks,
		Events:             relEvents,
		SpectatorChannelId: fbutils.GetStringSlot(table, 12),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (draft_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Draft, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (draft_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Draft), nil)
	}
	return append(slice.([]*Draft), object.(*Draft))
}

// Box provides CRUD access to Draft objects
type DraftBox struct {
	*objectbox.Box
}

// BoxForDraft opens a box of Draft objects
func BoxForDraft(ob *objectbox.ObjectBox) *DraftBox {
	return &DraftBox{
		Box: ob.InternalBox(2),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Draft.Id property on the passed object will be assigned the new ID as well.
func (box *DraftBox) Put(object *Draft) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Draft.Id property on the passed object will be assigned the new ID as well.
func (box *DraftBox) Insert(object *Draft) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *DraftBox) Update(object *Draft) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *DraftBox) PutAsync(object *Draft) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Draft.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Draft.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *DraftBox) PutMany(objects []*Draft) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *DraftBox) Get(id uint64) (*Draft, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Draft), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *DraftBox) GetMany(ids ...uint64) ([]*Draft, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Draft), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *DraftBox) GetManyExisting(ids ...uint64) ([]*Draft, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Draft), nil
}

// GetAll reads all stored objects
func (box *DraftBox) GetAll() ([]*Draft, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Draft), nil
}

// Remove deletes a single object
func (box *DraftBox) Remove(object *Draft) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *DraftBox) RemoveMany(objects ...*Draft) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Draft_ struct to create conditions.
// Keep the *DraftQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *DraftBox) Query(conditions ...objectbox.Condition) *DraftQuery {
	return &DraftQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Draft_ struct to create conditions.
// Keep the *DraftQuery if you intend to execute the query multiple times.
func (box *DraftBox) QueryOrError(conditions ...objectbox.Condition) (*DraftQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &DraftQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See DraftAsyncBox for more information.
func (box *DraftBox) Async() *DraftAsyncBox {
	return &DraftAsyncBox{AsyncBox: box.Box.Async()}
}

// DraftAsyncBox provides asynchronous operations on Draft objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type DraftAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForDraft creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use DraftBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForDraft(ob *objectbox.ObjectBox, timeoutMs uint64) *DraftAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 2, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 2: %s" + err.Error())
	}
	return &DraftAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *DraftAsyncBox) Put(object *Draft) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *DraftAsyncBox) Insert(object *Draft) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *DraftAsyncBox) Update(object *Draft) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *DraftAsyncBox) Remove(object *Draft) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Draft which Id is either 42 or 47:
//
// box.Query(Draft_.Id.In(42, 47)).Find()
type DraftQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *DraftQuery) Find() ([]*Draft, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Draft), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *DraftQuery) Offset(offset uint64) *DraftQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *DraftQuery) Limit(limit uint64) *DraftQuery {
	query.Query.Limit(limit)
	return query
}

type pack_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var PackBinding = pack_EntityInfo{
	Entity: objectbox.Entity{
		Id: 3,
	},
	Uid: 1155517256902974807,
}

// Pack_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Pack_ = struct {
	Id            *objectbox.PropertyUint64
	Round         *objectbox.PropertyInt
	OriginalCards *objectbox.RelationToMany
	Cards         *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &PackBinding.Entity,
		},
	},
	Round: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &PackBinding.Entity,
		},
	},
	OriginalCards: &objectbox.RelationToMany{
		Id:     3,
		Source: &PackBinding.Entity,
		Target: &CardBinding.Entity,
	},
	Cards: &objectbox.RelationToMany{
		Id:     4,
		Source: &PackBinding.Entity,
		Target: &CardBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (pack_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (pack_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Pack", 3, 1155517256902974807)
	model.Property("Id", 6, 1, 738798414154091846)
	model.PropertyFlags(1)
	model.Property("Round", 6, 2, 8935275349771071339)
	model.EntityLastPropertyId(2, 8935275349771071339)
	model.Relation(3, 416795459030113531, CardBinding.Id, CardBinding.Uid)
	model.Relation(4, 7372407126934531702, CardBinding.Id, CardBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (pack_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Pack).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (pack_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Pack).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (pack_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if err := BoxForPack(ob).RelationReplace(Pack_.OriginalCards, id, object, object.(*Pack).OriginalCards); err != nil {
		return err
	}

	if err := BoxForPack(ob).RelationReplace(Pack_.Cards, id, object, object.(*Pack).Cards); err != nil {
		return err
	}

	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (pack_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Pack)

	// build the FlatBuffers object
	fbb.StartObject(2)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetInt64Slot(fbb, 1, int64(obj.Round))
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (pack_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Pack' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relOriginalCards []*Card
	if rIds, err := BoxForPack(ob).RelationIds(Pack_.OriginalCards, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForCard(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relOriginalCards = rSlice
	}

	var relCards []*Card
	if rIds, err := BoxForPack(ob).RelationIds(Pack_.Cards, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForCard(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relCards = rSlice
	}

	return &Pack{
		Id:            propId,
		Round:         fbutils.GetIntSlot(table, 6),
		OriginalCards: relOriginalCards,
		Cards:         relCards,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (pack_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Pack, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (pack_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Pack), nil)
	}
	return append(slice.([]*Pack), object.(*Pack))
}

// Box provides CRUD access to Pack objects
type PackBox struct {
	*objectbox.Box
}

// BoxForPack opens a box of Pack objects
func BoxForPack(ob *objectbox.ObjectBox) *PackBox {
	return &PackBox{
		Box: ob.InternalBox(3),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Pack.Id property on the passed object will be assigned the new ID as well.
func (box *PackBox) Put(object *Pack) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Pack.Id property on the passed object will be assigned the new ID as well.
func (box *PackBox) Insert(object *Pack) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *PackBox) Update(object *Pack) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *PackBox) PutAsync(object *Pack) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Pack.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Pack.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *PackBox) PutMany(objects []*Pack) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *PackBox) Get(id uint64) (*Pack, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Pack), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *PackBox) GetMany(ids ...uint64) ([]*Pack, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Pack), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *PackBox) GetManyExisting(ids ...uint64) ([]*Pack, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Pack), nil
}

// GetAll reads all stored objects
func (box *PackBox) GetAll() ([]*Pack, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Pack), nil
}

// Remove deletes a single object
func (box *PackBox) Remove(object *Pack) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *PackBox) RemoveMany(objects ...*Pack) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Pack_ struct to create conditions.
// Keep the *PackQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *PackBox) Query(conditions ...objectbox.Condition) *PackQuery {
	return &PackQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Pack_ struct to create conditions.
// Keep the *PackQuery if you intend to execute the query multiple times.
func (box *PackBox) QueryOrError(conditions ...objectbox.Condition) (*PackQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &PackQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See PackAsyncBox for more information.
func (box *PackBox) Async() *PackAsyncBox {
	return &PackAsyncBox{AsyncBox: box.Box.Async()}
}

// PackAsyncBox provides asynchronous operations on Pack objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type PackAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForPack creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use PackBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForPack(ob *objectbox.ObjectBox, timeoutMs uint64) *PackAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 3, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 3: %s" + err.Error())
	}
	return &PackAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *PackAsyncBox) Put(object *Pack) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *PackAsyncBox) Insert(object *Pack) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *PackAsyncBox) Update(object *Pack) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *PackAsyncBox) Remove(object *Pack) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Pack which Id is either 42 or 47:
//
// box.Query(Pack_.Id.In(42, 47)).Find()
type PackQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *PackQuery) Find() ([]*Pack, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Pack), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *PackQuery) Offset(offset uint64) *PackQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *PackQuery) Limit(limit uint64) *PackQuery {
	query.Query.Limit(limit)
	return query
}

type seat_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SeatBinding = seat_EntityInfo{
	Entity: objectbox.Entity{
		Id: 4,
	},
	Uid: 4887936716414452540,
}

// Seat_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Seat_ = struct {
	Id            *objectbox.PropertyUint64
	Position      *objectbox.PropertyInt
	User          *objectbox.RelationToOne
	Round         *objectbox.PropertyInt
	ScanSound     *objectbox.PropertyInt
	ErrorSound    *objectbox.PropertyInt
	ReservedUser  *objectbox.RelationToOne
	Packs         *objectbox.RelationToMany
	OriginalPacks *objectbox.RelationToMany
	PickedCards   *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SeatBinding.Entity,
		},
	},
	Position: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &SeatBinding.Entity,
		},
	},
	User: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     3,
			Entity: &SeatBinding.Entity,
		},
		Target: &UserBinding.Entity,
	},
	Round: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &SeatBinding.Entity,
		},
	},
	ScanSound: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     5,
			Entity: &SeatBinding.Entity,
		},
	},
	ErrorSound: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     6,
			Entity: &SeatBinding.Entity,
		},
	},
	ReservedUser: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     7,
			Entity: &SeatBinding.Entity,
		},
		Target: &UserBinding.Entity,
	},
	Packs: &objectbox.RelationToMany{
		Id:     5,
		Source: &SeatBinding.Entity,
		Target: &PackBinding.Entity,
	},
	OriginalPacks: &objectbox.RelationToMany{
		Id:     6,
		Source: &SeatBinding.Entity,
		Target: &PackBinding.Entity,
	},
	PickedCards: &objectbox.RelationToMany{
		Id:     7,
		Source: &SeatBinding.Entity,
		Target: &CardBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (seat_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (seat_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Seat", 4, 4887936716414452540)
	model.Property("Id", 6, 1, 8078538147364094683)
	model.PropertyFlags(1)
	model.Property("Position", 6, 2, 2770904193133050794)
	model.Property("User", 11, 3, 7494406323403893610)
	model.PropertyFlags(520)
	model.PropertyRelation("User", 2, 7336966020615020520)
	model.Property("Round", 6, 4, 1831797613325508740)
	model.Property("ScanSound", 6, 5, 2650220096827722242)
	model.Property("ErrorSound", 6, 6, 8296297800027766072)
	model.Property("ReservedUser", 11, 7, 2175187569463296958)
	model.PropertyFlags(520)
	model.PropertyRelation("User", 4, 7361461358871369732)
	model.EntityLastPropertyId(7, 2175187569463296958)
	model.Relation(5, 6696446224981877860, PackBinding.Id, PackBinding.Uid)
	model.Relation(6, 9146694319596130362, PackBinding.Id, PackBinding.Uid)
	model.Relation(7, 8203968657580447748, CardBinding.Id, CardBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (seat_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Seat).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (seat_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Seat).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (seat_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := object.(*Seat).User; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForUser(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Seat).ReservedUser; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForUser(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if err := BoxForSeat(ob).RelationReplace(Seat_.Packs, id, object, object.(*Seat).Packs); err != nil {
		return err
	}

	if err := BoxForSeat(ob).RelationReplace(Seat_.OriginalPacks, id, object, object.(*Seat).OriginalPacks); err != nil {
		return err
	}

	if err := BoxForSeat(ob).RelationReplace(Seat_.PickedCards, id, object, object.(*Seat).PickedCards); err != nil {
		return err
	}

	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (seat_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Seat)

	var rIdUser uint64
	if rel := obj.User; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdUser = rId
		}
	}

	var rIdReservedUser uint64
	if rel := obj.ReservedUser; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdReservedUser = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(7)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetInt64Slot(fbb, 1, int64(obj.Position))
	if obj.User != nil {
		fbutils.SetUint64Slot(fbb, 2, rIdUser)
	}
	if obj.ReservedUser != nil {
		fbutils.SetUint64Slot(fbb, 6, rIdReservedUser)
	}
	fbutils.SetInt64Slot(fbb, 4, int64(obj.ScanSound))
	fbutils.SetInt64Slot(fbb, 5, int64(obj.ErrorSound))
	fbutils.SetInt64Slot(fbb, 3, int64(obj.Round))
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (seat_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Seat' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relUser *User
	if rId := fbutils.GetUint64PtrSlot(table, 8); rId != nil && *rId > 0 {
		if rObject, err := BoxForUser(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relUser = rObject
		}
	}

	var relReservedUser *User
	if rId := fbutils.GetUint64PtrSlot(table, 16); rId != nil && *rId > 0 {
		if rObject, err := BoxForUser(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relReservedUser = rObject
		}
	}

	var relPacks []*Pack
	if rIds, err := BoxForSeat(ob).RelationIds(Seat_.Packs, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForPack(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relPacks = rSlice
	}

	var relOriginalPacks []*Pack
	if rIds, err := BoxForSeat(ob).RelationIds(Seat_.OriginalPacks, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForPack(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relOriginalPacks = rSlice
	}

	var relPickedCards []*Card
	if rIds, err := BoxForSeat(ob).RelationIds(Seat_.PickedCards, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForCard(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relPickedCards = rSlice
	}

	return &Seat{
		Id:            propId,
		Position:      fbutils.GetIntSlot(table, 6),
		User:          relUser,
		ReservedUser:  relReservedUser,
		ScanSound:     fbutils.GetIntSlot(table, 12),
		ErrorSound:    fbutils.GetIntSlot(table, 14),
		Round:         fbutils.GetIntSlot(table, 10),
		Packs:         relPacks,
		OriginalPacks: relOriginalPacks,
		PickedCards:   relPickedCards,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (seat_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Seat, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (seat_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Seat), nil)
	}
	return append(slice.([]*Seat), object.(*Seat))
}

// Box provides CRUD access to Seat objects
type SeatBox struct {
	*objectbox.Box
}

// BoxForSeat opens a box of Seat objects
func BoxForSeat(ob *objectbox.ObjectBox) *SeatBox {
	return &SeatBox{
		Box: ob.InternalBox(4),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Seat.Id property on the passed object will be assigned the new ID as well.
func (box *SeatBox) Put(object *Seat) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Seat.Id property on the passed object will be assigned the new ID as well.
func (box *SeatBox) Insert(object *Seat) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SeatBox) Update(object *Seat) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SeatBox) PutAsync(object *Seat) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Seat.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Seat.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SeatBox) PutMany(objects []*Seat) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SeatBox) Get(id uint64) (*Seat, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Seat), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SeatBox) GetMany(ids ...uint64) ([]*Seat, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Seat), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SeatBox) GetManyExisting(ids ...uint64) ([]*Seat, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Seat), nil
}

// GetAll reads all stored objects
func (box *SeatBox) GetAll() ([]*Seat, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Seat), nil
}

// Remove deletes a single object
func (box *SeatBox) Remove(object *Seat) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SeatBox) RemoveMany(objects ...*Seat) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Seat_ struct to create conditions.
// Keep the *SeatQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SeatBox) Query(conditions ...objectbox.Condition) *SeatQuery {
	return &SeatQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Seat_ struct to create conditions.
// Keep the *SeatQuery if you intend to execute the query multiple times.
func (box *SeatBox) QueryOrError(conditions ...objectbox.Condition) (*SeatQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SeatQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SeatAsyncBox for more information.
func (box *SeatBox) Async() *SeatAsyncBox {
	return &SeatAsyncBox{AsyncBox: box.Box.Async()}
}

// SeatAsyncBox provides asynchronous operations on Seat objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SeatAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSeat creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SeatBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSeat(ob *objectbox.ObjectBox, timeoutMs uint64) *SeatAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 4, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 4: %s" + err.Error())
	}
	return &SeatAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SeatAsyncBox) Put(object *Seat) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SeatAsyncBox) Insert(object *Seat) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SeatAsyncBox) Update(object *Seat) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SeatAsyncBox) Remove(object *Seat) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Seat which Id is either 42 or 47:
//
// box.Query(Seat_.Id.In(42, 47)).Find()
type SeatQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SeatQuery) Find() ([]*Seat, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Seat), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SeatQuery) Offset(offset uint64) *SeatQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SeatQuery) Limit(limit uint64) *SeatQuery {
	query.Query.Limit(limit)
	return query
}

type user_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var UserBinding = user_EntityInfo{
	Entity: objectbox.Entity{
		Id: 5,
	},
	Uid: 4703981982501053839,
}

// User_ contains type-based Property helpers to facilitate some common operations such as Queries.
var User_ = struct {
	Id          *objectbox.PropertyUint64
	DiscordId   *objectbox.PropertyString
	DiscordName *objectbox.PropertyString
	Picture     *objectbox.PropertyString
	MtgoName    *objectbox.PropertyString
	Skips       *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &UserBinding.Entity,
		},
	},
	DiscordId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &UserBinding.Entity,
		},
	},
	DiscordName: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &UserBinding.Entity,
		},
	},
	Picture: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &UserBinding.Entity,
		},
	},
	MtgoName: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     5,
			Entity: &UserBinding.Entity,
		},
	},
	Skips: &objectbox.RelationToMany{
		Id:     9,
		Source: &UserBinding.Entity,
		Target: &SkipBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (user_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (user_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("User", 5, 4703981982501053839)
	model.Property("Id", 6, 1, 987361712691974179)
	model.PropertyFlags(1)
	model.Property("DiscordId", 9, 2, 4218050236313686403)
	model.PropertyFlags(2080)
	model.PropertyIndex(3, 5730927515722964384)
	model.Property("DiscordName", 9, 3, 2883176456415605197)
	model.Property("Picture", 9, 4, 8627742690429822644)
	model.Property("MtgoName", 9, 5, 7487591356744068798)
	model.EntityLastPropertyId(5, 7487591356744068798)
	model.Relation(9, 6610520635914740722, SkipBinding.Id, SkipBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (user_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*User).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (user_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*User).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (user_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if err := BoxForUser(ob).RelationReplace(User_.Skips, id, object, object.(*User).Skips); err != nil {
		return err
	}

	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (user_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*User)
	var offsetDiscordId = fbutils.CreateStringOffset(fbb, obj.DiscordId)
	var offsetDiscordName = fbutils.CreateStringOffset(fbb, obj.DiscordName)
	var offsetPicture = fbutils.CreateStringOffset(fbb, obj.Picture)
	var offsetMtgoName = fbutils.CreateStringOffset(fbb, obj.MtgoName)

	// build the FlatBuffers object
	fbb.StartObject(5)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetDiscordId)
	fbutils.SetUOffsetTSlot(fbb, 2, offsetDiscordName)
	fbutils.SetUOffsetTSlot(fbb, 4, offsetMtgoName)
	fbutils.SetUOffsetTSlot(fbb, 3, offsetPicture)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (user_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'User' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relSkips []*Skip
	if rIds, err := BoxForUser(ob).RelationIds(User_.Skips, propId); err != nil {
		return nil, err
	} else if rSlice, err := BoxForSkip(ob).GetManyExisting(rIds...); err != nil {
		return nil, err
	} else {
		relSkips = rSlice
	}

	return &User{
		Id:          propId,
		DiscordId:   fbutils.GetStringSlot(table, 6),
		DiscordName: fbutils.GetStringSlot(table, 8),
		MtgoName:    fbutils.GetStringSlot(table, 12),
		Picture:     fbutils.GetStringSlot(table, 10),
		Skips:       relSkips,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (user_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*User, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (user_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*User), nil)
	}
	return append(slice.([]*User), object.(*User))
}

// Box provides CRUD access to User objects
type UserBox struct {
	*objectbox.Box
}

// BoxForUser opens a box of User objects
func BoxForUser(ob *objectbox.ObjectBox) *UserBox {
	return &UserBox{
		Box: ob.InternalBox(5),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the User.Id property on the passed object will be assigned the new ID as well.
func (box *UserBox) Put(object *User) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the User.Id property on the passed object will be assigned the new ID as well.
func (box *UserBox) Insert(object *User) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *UserBox) Update(object *User) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *UserBox) PutAsync(object *User) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the User.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the User.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *UserBox) PutMany(objects []*User) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *UserBox) Get(id uint64) (*User, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*User), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *UserBox) GetMany(ids ...uint64) ([]*User, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*User), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *UserBox) GetManyExisting(ids ...uint64) ([]*User, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*User), nil
}

// GetAll reads all stored objects
func (box *UserBox) GetAll() ([]*User, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*User), nil
}

// Remove deletes a single object
func (box *UserBox) Remove(object *User) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *UserBox) RemoveMany(objects ...*User) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the User_ struct to create conditions.
// Keep the *UserQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *UserBox) Query(conditions ...objectbox.Condition) *UserQuery {
	return &UserQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the User_ struct to create conditions.
// Keep the *UserQuery if you intend to execute the query multiple times.
func (box *UserBox) QueryOrError(conditions ...objectbox.Condition) (*UserQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &UserQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See UserAsyncBox for more information.
func (box *UserBox) Async() *UserAsyncBox {
	return &UserAsyncBox{AsyncBox: box.Box.Async()}
}

// UserAsyncBox provides asynchronous operations on User objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type UserAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForUser creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use UserBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForUser(ob *objectbox.ObjectBox, timeoutMs uint64) *UserAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 5, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 5: %s" + err.Error())
	}
	return &UserAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *UserAsyncBox) Put(object *User) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *UserAsyncBox) Insert(object *User) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *UserAsyncBox) Update(object *User) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *UserAsyncBox) Remove(object *User) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all User which Id is either 42 or 47:
//
// box.Query(User_.Id.In(42, 47)).Find()
type UserQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *UserQuery) Find() ([]*User, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*User), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *UserQuery) Offset(offset uint64) *UserQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *UserQuery) Limit(limit uint64) *UserQuery {
	query.Query.Limit(limit)
	return query
}

type event_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var EventBinding = event_EntityInfo{
	Entity: objectbox.Entity{
		Id: 6,
	},
	Uid: 7673531568455826754,
}

// Event_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Event_ = struct {
	Id           *objectbox.PropertyUint64
	Position     *objectbox.PropertyInt
	Announcement *objectbox.PropertyString
	Modified     *objectbox.PropertyInt
	Round        *objectbox.PropertyInt
	Card1        *objectbox.RelationToOne
	Card2        *objectbox.RelationToOne
	Pack         *objectbox.RelationToOne
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &EventBinding.Entity,
		},
	},
	Position: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &EventBinding.Entity,
		},
	},
	Announcement: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &EventBinding.Entity,
		},
	},
	Modified: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     10,
			Entity: &EventBinding.Entity,
		},
	},
	Round: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     11,
			Entity: &EventBinding.Entity,
		},
	},
	Card1: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     24,
			Entity: &EventBinding.Entity,
		},
		Target: &CardBinding.Entity,
	},
	Card2: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     25,
			Entity: &EventBinding.Entity,
		},
		Target: &CardBinding.Entity,
	},
	Pack: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     26,
			Entity: &EventBinding.Entity,
		},
		Target: &PackBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (event_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (event_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Event", 6, 7673531568455826754)
	model.Property("Id", 6, 1, 7948667117051851965)
	model.PropertyFlags(1)
	model.Property("Position", 6, 2, 6134006601491701085)
	model.Property("Announcement", 9, 3, 4300446115445441902)
	model.Property("Modified", 6, 10, 8736377686176001505)
	model.Property("Round", 6, 11, 1935204458196918156)
	model.Property("Card1", 11, 24, 1432834121224423321)
	model.PropertyFlags(520)
	model.PropertyRelation("Card", 5, 6315904713288332300)
	model.Property("Card2", 11, 25, 3938773008361457094)
	model.PropertyFlags(520)
	model.PropertyRelation("Card", 6, 9101246984390296186)
	model.Property("Pack", 11, 26, 8224660085647238639)
	model.PropertyFlags(520)
	model.PropertyRelation("Pack", 7, 6451483386392342396)
	model.EntityLastPropertyId(26, 8224660085647238639)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (event_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Event).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (event_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Event).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (event_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := object.(*Event).Card1; rel != nil {
		if rId, err := CardBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForCard(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Event).Card2; rel != nil {
		if rId, err := CardBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForCard(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Event).Pack; rel != nil {
		if rId, err := PackBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForPack(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (event_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Event)
	var offsetAnnouncement = fbutils.CreateStringOffset(fbb, obj.Announcement)

	var rIdCard1 uint64
	if rel := obj.Card1; rel != nil {
		if rId, err := CardBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdCard1 = rId
		}
	}

	var rIdCard2 uint64
	if rel := obj.Card2; rel != nil {
		if rId, err := CardBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdCard2 = rId
		}
	}

	var rIdPack uint64
	if rel := obj.Pack; rel != nil {
		if rId, err := PackBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdPack = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(26)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetInt64Slot(fbb, 1, int64(obj.Position))
	fbutils.SetUOffsetTSlot(fbb, 2, offsetAnnouncement)
	if obj.Card1 != nil {
		fbutils.SetUint64Slot(fbb, 23, rIdCard1)
	}
	if obj.Card2 != nil {
		fbutils.SetUint64Slot(fbb, 24, rIdCard2)
	}
	if obj.Pack != nil {
		fbutils.SetUint64Slot(fbb, 25, rIdPack)
	}
	fbutils.SetInt64Slot(fbb, 9, int64(obj.Modified))
	fbutils.SetInt64Slot(fbb, 10, int64(obj.Round))
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (event_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Event' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relCard1 *Card
	if rId := fbutils.GetUint64PtrSlot(table, 50); rId != nil && *rId > 0 {
		if rObject, err := BoxForCard(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relCard1 = rObject
		}
	}

	var relCard2 *Card
	if rId := fbutils.GetUint64PtrSlot(table, 52); rId != nil && *rId > 0 {
		if rObject, err := BoxForCard(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relCard2 = rObject
		}
	}

	var relPack *Pack
	if rId := fbutils.GetUint64PtrSlot(table, 54); rId != nil && *rId > 0 {
		if rObject, err := BoxForPack(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relPack = rObject
		}
	}

	return &Event{
		Id:           propId,
		Position:     fbutils.GetIntSlot(table, 6),
		Announcement: fbutils.GetStringSlot(table, 8),
		Card1:        relCard1,
		Card2:        relCard2,
		Pack:         relPack,
		Modified:     fbutils.GetIntSlot(table, 22),
		Round:        fbutils.GetIntSlot(table, 24),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (event_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Event, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (event_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Event), nil)
	}
	return append(slice.([]*Event), object.(*Event))
}

// Box provides CRUD access to Event objects
type EventBox struct {
	*objectbox.Box
}

// BoxForEvent opens a box of Event objects
func BoxForEvent(ob *objectbox.ObjectBox) *EventBox {
	return &EventBox{
		Box: ob.InternalBox(6),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Event.Id property on the passed object will be assigned the new ID as well.
func (box *EventBox) Put(object *Event) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Event.Id property on the passed object will be assigned the new ID as well.
func (box *EventBox) Insert(object *Event) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *EventBox) Update(object *Event) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *EventBox) PutAsync(object *Event) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Event.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Event.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *EventBox) PutMany(objects []*Event) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *EventBox) Get(id uint64) (*Event, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Event), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *EventBox) GetMany(ids ...uint64) ([]*Event, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Event), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *EventBox) GetManyExisting(ids ...uint64) ([]*Event, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Event), nil
}

// GetAll reads all stored objects
func (box *EventBox) GetAll() ([]*Event, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Event), nil
}

// Remove deletes a single object
func (box *EventBox) Remove(object *Event) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *EventBox) RemoveMany(objects ...*Event) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Event_ struct to create conditions.
// Keep the *EventQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *EventBox) Query(conditions ...objectbox.Condition) *EventQuery {
	return &EventQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Event_ struct to create conditions.
// Keep the *EventQuery if you intend to execute the query multiple times.
func (box *EventBox) QueryOrError(conditions ...objectbox.Condition) (*EventQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &EventQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See EventAsyncBox for more information.
func (box *EventBox) Async() *EventAsyncBox {
	return &EventAsyncBox{AsyncBox: box.Box.Async()}
}

// EventAsyncBox provides asynchronous operations on Event objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type EventAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForEvent creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use EventBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForEvent(ob *objectbox.ObjectBox, timeoutMs uint64) *EventAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 6, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 6: %s" + err.Error())
	}
	return &EventAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *EventAsyncBox) Put(object *Event) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *EventAsyncBox) Insert(object *Event) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *EventAsyncBox) Update(object *Event) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *EventAsyncBox) Remove(object *Event) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Event which Id is either 42 or 47:
//
// box.Query(Event_.Id.In(42, 47)).Find()
type EventQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *EventQuery) Find() ([]*Event, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Event), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *EventQuery) Offset(offset uint64) *EventQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *EventQuery) Limit(limit uint64) *EventQuery {
	query.Query.Limit(limit)
	return query
}

type skip_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var SkipBinding = skip_EntityInfo{
	Entity: objectbox.Entity{
		Id: 7,
	},
	Uid: 582453211065114336,
}

// Skip_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Skip_ = struct {
	Id      *objectbox.PropertyUint64
	DraftId *objectbox.PropertyUint64
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &SkipBinding.Entity,
		},
	},
	DraftId: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &SkipBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (skip_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (skip_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Skip", 7, 582453211065114336)
	model.Property("Id", 6, 1, 5986743686620962817)
	model.PropertyFlags(1)
	model.Property("DraftId", 6, 4, 13933496088550140)
	model.PropertyFlags(8192)
	model.EntityLastPropertyId(4, 13933496088550140)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (skip_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Skip).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (skip_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Skip).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (skip_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (skip_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Skip)

	// build the FlatBuffers object
	fbb.StartObject(4)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUint64Slot(fbb, 3, obj.DraftId)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (skip_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Skip' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	return &Skip{
		Id:      propId,
		DraftId: fbutils.GetUint64Slot(table, 10),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (skip_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Skip, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (skip_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Skip), nil)
	}
	return append(slice.([]*Skip), object.(*Skip))
}

// Box provides CRUD access to Skip objects
type SkipBox struct {
	*objectbox.Box
}

// BoxForSkip opens a box of Skip objects
func BoxForSkip(ob *objectbox.ObjectBox) *SkipBox {
	return &SkipBox{
		Box: ob.InternalBox(7),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Skip.Id property on the passed object will be assigned the new ID as well.
func (box *SkipBox) Put(object *Skip) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Skip.Id property on the passed object will be assigned the new ID as well.
func (box *SkipBox) Insert(object *Skip) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *SkipBox) Update(object *Skip) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *SkipBox) PutAsync(object *Skip) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Skip.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Skip.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *SkipBox) PutMany(objects []*Skip) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *SkipBox) Get(id uint64) (*Skip, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Skip), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *SkipBox) GetMany(ids ...uint64) ([]*Skip, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Skip), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *SkipBox) GetManyExisting(ids ...uint64) ([]*Skip, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Skip), nil
}

// GetAll reads all stored objects
func (box *SkipBox) GetAll() ([]*Skip, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Skip), nil
}

// Remove deletes a single object
func (box *SkipBox) Remove(object *Skip) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *SkipBox) RemoveMany(objects ...*Skip) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Skip_ struct to create conditions.
// Keep the *SkipQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *SkipBox) Query(conditions ...objectbox.Condition) *SkipQuery {
	return &SkipQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Skip_ struct to create conditions.
// Keep the *SkipQuery if you intend to execute the query multiple times.
func (box *SkipBox) QueryOrError(conditions ...objectbox.Condition) (*SkipQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &SkipQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See SkipAsyncBox for more information.
func (box *SkipBox) Async() *SkipAsyncBox {
	return &SkipAsyncBox{AsyncBox: box.Box.Async()}
}

// SkipAsyncBox provides asynchronous operations on Skip objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type SkipAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForSkip creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use SkipBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForSkip(ob *objectbox.ObjectBox, timeoutMs uint64) *SkipAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 7, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 7: %s" + err.Error())
	}
	return &SkipAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *SkipAsyncBox) Put(object *Skip) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *SkipAsyncBox) Insert(object *Skip) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *SkipAsyncBox) Update(object *Skip) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *SkipAsyncBox) Remove(object *Skip) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Skip which Id is either 42 or 47:
//
// box.Query(Skip_.Id.In(42, 47)).Find()
type SkipQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *SkipQuery) Find() ([]*Skip, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Skip), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *SkipQuery) Offset(offset uint64) *SkipQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *SkipQuery) Limit(limit uint64) *SkipQuery {
	query.Query.Limit(limit)
	return query
}

type roleMsg_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var RoleMsgBinding = roleMsg_EntityInfo{
	Entity: objectbox.Entity{
		Id: 8,
	},
	Uid: 4584161552244482205,
}

// RoleMsg_ contains type-based Property helpers to facilitate some common operations such as Queries.
var RoleMsg_ = struct {
	Id     *objectbox.PropertyUint64
	MsgId  *objectbox.PropertyString
	Emoji  *objectbox.PropertyString
	RoleId *objectbox.PropertyString
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &RoleMsgBinding.Entity,
		},
	},
	MsgId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &RoleMsgBinding.Entity,
		},
	},
	Emoji: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &RoleMsgBinding.Entity,
		},
	},
	RoleId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &RoleMsgBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (roleMsg_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (roleMsg_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("RoleMsg", 8, 4584161552244482205)
	model.Property("Id", 6, 1, 2381386492686567280)
	model.PropertyFlags(1)
	model.Property("MsgId", 9, 2, 7320684024754515890)
	model.PropertyFlags(2048)
	model.PropertyIndex(10, 257225024409141033)
	model.Property("Emoji", 9, 3, 7239069582421067485)
	model.Property("RoleId", 9, 4, 5487559797794397540)
	model.EntityLastPropertyId(4, 5487559797794397540)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (roleMsg_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*RoleMsg).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (roleMsg_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*RoleMsg).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (roleMsg_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (roleMsg_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*RoleMsg)
	var offsetMsgId = fbutils.CreateStringOffset(fbb, obj.MsgId)
	var offsetEmoji = fbutils.CreateStringOffset(fbb, obj.Emoji)
	var offsetRoleId = fbutils.CreateStringOffset(fbb, obj.RoleId)

	// build the FlatBuffers object
	fbb.StartObject(4)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetMsgId)
	fbutils.SetUOffsetTSlot(fbb, 2, offsetEmoji)
	fbutils.SetUOffsetTSlot(fbb, 3, offsetRoleId)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (roleMsg_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'RoleMsg' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	return &RoleMsg{
		Id:     propId,
		MsgId:  fbutils.GetStringSlot(table, 6),
		Emoji:  fbutils.GetStringSlot(table, 8),
		RoleId: fbutils.GetStringSlot(table, 10),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (roleMsg_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*RoleMsg, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (roleMsg_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*RoleMsg), nil)
	}
	return append(slice.([]*RoleMsg), object.(*RoleMsg))
}

// Box provides CRUD access to RoleMsg objects
type RoleMsgBox struct {
	*objectbox.Box
}

// BoxForRoleMsg opens a box of RoleMsg objects
func BoxForRoleMsg(ob *objectbox.ObjectBox) *RoleMsgBox {
	return &RoleMsgBox{
		Box: ob.InternalBox(8),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the RoleMsg.Id property on the passed object will be assigned the new ID as well.
func (box *RoleMsgBox) Put(object *RoleMsg) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the RoleMsg.Id property on the passed object will be assigned the new ID as well.
func (box *RoleMsgBox) Insert(object *RoleMsg) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *RoleMsgBox) Update(object *RoleMsg) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *RoleMsgBox) PutAsync(object *RoleMsg) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the RoleMsg.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the RoleMsg.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *RoleMsgBox) PutMany(objects []*RoleMsg) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *RoleMsgBox) Get(id uint64) (*RoleMsg, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*RoleMsg), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *RoleMsgBox) GetMany(ids ...uint64) ([]*RoleMsg, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*RoleMsg), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *RoleMsgBox) GetManyExisting(ids ...uint64) ([]*RoleMsg, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*RoleMsg), nil
}

// GetAll reads all stored objects
func (box *RoleMsgBox) GetAll() ([]*RoleMsg, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*RoleMsg), nil
}

// Remove deletes a single object
func (box *RoleMsgBox) Remove(object *RoleMsg) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *RoleMsgBox) RemoveMany(objects ...*RoleMsg) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the RoleMsg_ struct to create conditions.
// Keep the *RoleMsgQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *RoleMsgBox) Query(conditions ...objectbox.Condition) *RoleMsgQuery {
	return &RoleMsgQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the RoleMsg_ struct to create conditions.
// Keep the *RoleMsgQuery if you intend to execute the query multiple times.
func (box *RoleMsgBox) QueryOrError(conditions ...objectbox.Condition) (*RoleMsgQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &RoleMsgQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See RoleMsgAsyncBox for more information.
func (box *RoleMsgBox) Async() *RoleMsgAsyncBox {
	return &RoleMsgAsyncBox{AsyncBox: box.Box.Async()}
}

// RoleMsgAsyncBox provides asynchronous operations on RoleMsg objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type RoleMsgAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForRoleMsg creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use RoleMsgBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForRoleMsg(ob *objectbox.ObjectBox, timeoutMs uint64) *RoleMsgAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 8, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 8: %s" + err.Error())
	}
	return &RoleMsgAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *RoleMsgAsyncBox) Put(object *RoleMsg) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *RoleMsgAsyncBox) Insert(object *RoleMsg) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *RoleMsgAsyncBox) Update(object *RoleMsg) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *RoleMsgAsyncBox) Remove(object *RoleMsg) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all RoleMsg which Id is either 42 or 47:
//
// box.Query(RoleMsg_.Id.In(42, 47)).Find()
type RoleMsgQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *RoleMsgQuery) Find() ([]*RoleMsg, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*RoleMsg), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *RoleMsgQuery) Offset(offset uint64) *RoleMsgQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *RoleMsgQuery) Limit(limit uint64) *RoleMsgQuery {
	query.Query.Limit(limit)
	return query
}

type pairingMsg_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var PairingMsgBinding = pairingMsg_EntityInfo{
	Entity: objectbox.Entity{
		Id: 9,
	},
	Uid: 5556830914062522448,
}

// PairingMsg_ contains type-based Property helpers to facilitate some common operations such as Queries.
var PairingMsg_ = struct {
	Id    *objectbox.PropertyUint64
	MsgId *objectbox.PropertyString
	Draft *objectbox.RelationToOne
	Round *objectbox.PropertyInt
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &PairingMsgBinding.Entity,
		},
	},
	MsgId: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &PairingMsgBinding.Entity,
		},
	},
	Draft: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     3,
			Entity: &PairingMsgBinding.Entity,
		},
		Target: &DraftBinding.Entity,
	},
	Round: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &PairingMsgBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (pairingMsg_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (pairingMsg_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("PairingMsg", 9, 5556830914062522448)
	model.Property("Id", 6, 1, 6875302057371330696)
	model.PropertyFlags(1)
	model.Property("MsgId", 9, 2, 4324538381871134955)
	model.PropertyFlags(2048)
	model.PropertyIndex(14, 4152033847225781411)
	model.Property("Draft", 11, 3, 5369570367063193531)
	model.PropertyFlags(520)
	model.PropertyRelation("Draft", 11, 8482295304031901037)
	model.Property("Round", 6, 4, 6416533602933382533)
	model.EntityLastPropertyId(4, 6416533602933382533)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (pairingMsg_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*PairingMsg).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (pairingMsg_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*PairingMsg).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (pairingMsg_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := object.(*PairingMsg).Draft; rel != nil {
		if rId, err := DraftBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForDraft(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (pairingMsg_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*PairingMsg)
	var offsetMsgId = fbutils.CreateStringOffset(fbb, obj.MsgId)

	var rIdDraft uint64
	if rel := obj.Draft; rel != nil {
		if rId, err := DraftBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdDraft = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(4)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetMsgId)
	if obj.Draft != nil {
		fbutils.SetUint64Slot(fbb, 2, rIdDraft)
	}
	fbutils.SetInt64Slot(fbb, 3, int64(obj.Round))
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (pairingMsg_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'PairingMsg' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	var relDraft *Draft
	if rId := fbutils.GetUint64PtrSlot(table, 8); rId != nil && *rId > 0 {
		if rObject, err := BoxForDraft(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relDraft = rObject
		}
	}

	return &PairingMsg{
		Id:    propId,
		MsgId: fbutils.GetStringSlot(table, 6),
		Draft: relDraft,
		Round: fbutils.GetIntSlot(table, 10),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (pairingMsg_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*PairingMsg, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (pairingMsg_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*PairingMsg), nil)
	}
	return append(slice.([]*PairingMsg), object.(*PairingMsg))
}

// Box provides CRUD access to PairingMsg objects
type PairingMsgBox struct {
	*objectbox.Box
}

// BoxForPairingMsg opens a box of PairingMsg objects
func BoxForPairingMsg(ob *objectbox.ObjectBox) *PairingMsgBox {
	return &PairingMsgBox{
		Box: ob.InternalBox(9),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the PairingMsg.Id property on the passed object will be assigned the new ID as well.
func (box *PairingMsgBox) Put(object *PairingMsg) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the PairingMsg.Id property on the passed object will be assigned the new ID as well.
func (box *PairingMsgBox) Insert(object *PairingMsg) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *PairingMsgBox) Update(object *PairingMsg) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *PairingMsgBox) PutAsync(object *PairingMsg) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the PairingMsg.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the PairingMsg.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *PairingMsgBox) PutMany(objects []*PairingMsg) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *PairingMsgBox) Get(id uint64) (*PairingMsg, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*PairingMsg), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *PairingMsgBox) GetMany(ids ...uint64) ([]*PairingMsg, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*PairingMsg), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *PairingMsgBox) GetManyExisting(ids ...uint64) ([]*PairingMsg, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*PairingMsg), nil
}

// GetAll reads all stored objects
func (box *PairingMsgBox) GetAll() ([]*PairingMsg, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*PairingMsg), nil
}

// Remove deletes a single object
func (box *PairingMsgBox) Remove(object *PairingMsg) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *PairingMsgBox) RemoveMany(objects ...*PairingMsg) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the PairingMsg_ struct to create conditions.
// Keep the *PairingMsgQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *PairingMsgBox) Query(conditions ...objectbox.Condition) *PairingMsgQuery {
	return &PairingMsgQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the PairingMsg_ struct to create conditions.
// Keep the *PairingMsgQuery if you intend to execute the query multiple times.
func (box *PairingMsgBox) QueryOrError(conditions ...objectbox.Condition) (*PairingMsgQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &PairingMsgQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See PairingMsgAsyncBox for more information.
func (box *PairingMsgBox) Async() *PairingMsgAsyncBox {
	return &PairingMsgAsyncBox{AsyncBox: box.Box.Async()}
}

// PairingMsgAsyncBox provides asynchronous operations on PairingMsg objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type PairingMsgAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForPairingMsg creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use PairingMsgBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForPairingMsg(ob *objectbox.ObjectBox, timeoutMs uint64) *PairingMsgAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 9, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 9: %s" + err.Error())
	}
	return &PairingMsgAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *PairingMsgAsyncBox) Put(object *PairingMsg) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *PairingMsgAsyncBox) Insert(object *PairingMsg) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *PairingMsgAsyncBox) Update(object *PairingMsg) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *PairingMsgAsyncBox) Remove(object *PairingMsg) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all PairingMsg which Id is either 42 or 47:
//
// box.Query(PairingMsg_.Id.In(42, 47)).Find()
type PairingMsgQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *PairingMsgQuery) Find() ([]*PairingMsg, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*PairingMsg), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *PairingMsgQuery) Offset(offset uint64) *PairingMsgQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *PairingMsgQuery) Limit(limit uint64) *PairingMsgQuery {
	query.Query.Limit(limit)
	return query
}

type result_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var ResultBinding = result_EntityInfo{
	Entity: objectbox.Entity{
		Id: 10,
	},
	Uid: 3741662715507038888,
}

// Result_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Result_ = struct {
	Id        *objectbox.PropertyUint64
	Draft     *objectbox.RelationToOne
	Round     *objectbox.PropertyInt
	User      *objectbox.RelationToOne
	Win       *objectbox.PropertyBool
	Timestamp *objectbox.PropertyInt64
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &ResultBinding.Entity,
		},
	},
	Draft: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     2,
			Entity: &ResultBinding.Entity,
		},
		Target: &DraftBinding.Entity,
	},
	Round: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &ResultBinding.Entity,
		},
	},
	User: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     4,
			Entity: &ResultBinding.Entity,
		},
		Target: &UserBinding.Entity,
	},
	Win: &objectbox.PropertyBool{
		BaseProperty: &objectbox.BaseProperty{
			Id:     5,
			Entity: &ResultBinding.Entity,
		},
	},
	Timestamp: &objectbox.PropertyInt64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     6,
			Entity: &ResultBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (result_EntityInfo) GeneratorVersion() int {
	return 6
}

// AddToModel is called by ObjectBox during model build
func (result_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Result", 10, 3741662715507038888)
	model.Property("Id", 6, 1, 2128552977513607215)
	model.PropertyFlags(1)
	model.Property("Draft", 11, 2, 7878005627423439470)
	model.PropertyFlags(520)
	model.PropertyRelation("Draft", 12, 6538780904884724116)
	model.Property("Round", 6, 3, 5168398546860109702)
	model.Property("User", 11, 4, 8695695771983877724)
	model.PropertyFlags(520)
	model.PropertyRelation("User", 13, 388245969538914106)
	model.Property("Win", 1, 5, 984428142389294433)
	model.Property("Timestamp", 10, 6, 5243503137203354931)
	model.EntityLastPropertyId(6, 5243503137203354931)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (result_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Result).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (result_EntityInfo) SetId(object interface{}, id uint64) error {
	object.(*Result).Id = id
	return nil
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (result_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := object.(*Result).Draft; rel != nil {
		if rId, err := DraftBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForDraft(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Result).User; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForUser(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (result_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Result)
	var propTimestamp int64
	{
		var err error
		propTimestamp, err = objectbox.TimeInt64ConvertToDatabaseValue(obj.Timestamp)
		if err != nil {
			return errors.New("converter objectbox.TimeInt64ConvertToDatabaseValue() failed on Result.Timestamp: " + err.Error())
		}
	}

	var rIdDraft uint64
	if rel := obj.Draft; rel != nil {
		if rId, err := DraftBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdDraft = rId
		}
	}

	var rIdUser uint64
	if rel := obj.User; rel != nil {
		if rId, err := UserBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdUser = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(6)
	fbutils.SetUint64Slot(fbb, 0, id)
	if obj.Draft != nil {
		fbutils.SetUint64Slot(fbb, 1, rIdDraft)
	}
	fbutils.SetInt64Slot(fbb, 2, int64(obj.Round))
	if obj.User != nil {
		fbutils.SetUint64Slot(fbb, 3, rIdUser)
	}
	fbutils.SetBoolSlot(fbb, 4, obj.Win)
	fbutils.SetInt64Slot(fbb, 5, propTimestamp)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (result_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	if len(bytes) == 0 { // sanity check, should "never" happen
		return nil, errors.New("can't deserialize an object of type 'Result' - no data received")
	}

	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}

	var propId = table.GetUint64Slot(4, 0)

	propTimestamp, err := objectbox.TimeInt64ConvertToEntityProperty(fbutils.GetInt64Slot(table, 14))
	if err != nil {
		return nil, errors.New("converter objectbox.TimeInt64ConvertToEntityProperty() failed on Result.Timestamp: " + err.Error())
	}

	var relDraft *Draft
	if rId := fbutils.GetUint64PtrSlot(table, 6); rId != nil && *rId > 0 {
		if rObject, err := BoxForDraft(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relDraft = rObject
		}
	}

	var relUser *User
	if rId := fbutils.GetUint64PtrSlot(table, 10); rId != nil && *rId > 0 {
		if rObject, err := BoxForUser(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relUser = rObject
		}
	}

	return &Result{
		Id:        propId,
		Draft:     relDraft,
		Round:     fbutils.GetIntSlot(table, 8),
		User:      relUser,
		Win:       fbutils.GetBoolSlot(table, 12),
		Timestamp: propTimestamp,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (result_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Result, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (result_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	if object == nil {
		return append(slice.([]*Result), nil)
	}
	return append(slice.([]*Result), object.(*Result))
}

// Box provides CRUD access to Result objects
type ResultBox struct {
	*objectbox.Box
}

// BoxForResult opens a box of Result objects
func BoxForResult(ob *objectbox.ObjectBox) *ResultBox {
	return &ResultBox{
		Box: ob.InternalBox(10),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Result.Id property on the passed object will be assigned the new ID as well.
func (box *ResultBox) Put(object *Result) (uint64, error) {
	return box.Box.Put(object)
}

// Insert synchronously inserts a single object. As opposed to Put, Insert will fail if given an ID that already exists.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Result.Id property on the passed object will be assigned the new ID as well.
func (box *ResultBox) Insert(object *Result) (uint64, error) {
	return box.Box.Insert(object)
}

// Update synchronously updates a single object.
// As opposed to Put, Update will fail if an object with the same ID is not found in the database.
func (box *ResultBox) Update(object *Result) error {
	return box.Box.Update(object)
}

// PutAsync asynchronously inserts/updates a single object.
// Deprecated: use box.Async().Put() instead
func (box *ResultBox) PutAsync(object *Result) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Result.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Result.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *ResultBox) PutMany(objects []*Result) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *ResultBox) Get(id uint64) (*Result, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Result), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *ResultBox) GetMany(ids ...uint64) ([]*Result, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Result), nil
}

// GetManyExisting reads multiple objects at once, skipping those that do not exist.
func (box *ResultBox) GetManyExisting(ids ...uint64) ([]*Result, error) {
	objects, err := box.Box.GetManyExisting(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Result), nil
}

// GetAll reads all stored objects
func (box *ResultBox) GetAll() ([]*Result, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Result), nil
}

// Remove deletes a single object
func (box *ResultBox) Remove(object *Result) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *ResultBox) RemoveMany(objects ...*Result) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Result_ struct to create conditions.
// Keep the *ResultQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *ResultBox) Query(conditions ...objectbox.Condition) *ResultQuery {
	return &ResultQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Result_ struct to create conditions.
// Keep the *ResultQuery if you intend to execute the query multiple times.
func (box *ResultBox) QueryOrError(conditions ...objectbox.Condition) (*ResultQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &ResultQuery{query}, nil
	}
}

// Async provides access to the default Async Box for asynchronous operations. See ResultAsyncBox for more information.
func (box *ResultBox) Async() *ResultAsyncBox {
	return &ResultAsyncBox{AsyncBox: box.Box.Async()}
}

// ResultAsyncBox provides asynchronous operations on Result objects.
//
// Asynchronous operations are executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "execute & forget:" you gain faster put/remove operations as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
// In situations with (extremely) high async load, an async method may be throttled (~1ms) or delayed up to 1 second.
// In the unlikely event that the object could still not be enqueued (full queue), an error will be returned.
//
// Note that async methods do not give you hard durability guarantees like the synchronous Box provides.
// There is a small time window in which the data may not have been committed durably yet.
type ResultAsyncBox struct {
	*objectbox.AsyncBox
}

// AsyncBoxForResult creates a new async box with the given operation timeout in case an async queue is full.
// The returned struct must be freed explicitly using the Close() method.
// It's usually preferable to use ResultBox::Async() which takes care of resource management and doesn't require closing.
func AsyncBoxForResult(ob *objectbox.ObjectBox, timeoutMs uint64) *ResultAsyncBox {
	var async, err = objectbox.NewAsyncBox(ob, 10, timeoutMs)
	if err != nil {
		panic("Could not create async box for entity ID 10: %s" + err.Error())
	}
	return &ResultAsyncBox{AsyncBox: async}
}

// Put inserts/updates a single object asynchronously.
// When inserting a new object, the Id property on the passed object will be assigned the new ID the entity would hold
// if the insert is ultimately successful. The newly assigned ID may not become valid if the insert fails.
func (asyncBox *ResultAsyncBox) Put(object *Result) (uint64, error) {
	return asyncBox.AsyncBox.Put(object)
}

// Insert a single object asynchronously.
// The Id property on the passed object will be assigned the new ID the entity would hold if the insert is ultimately
// successful. The newly assigned ID may not become valid if the insert fails.
// Fails silently if an object with the same ID already exists (this error is not returned).
func (asyncBox *ResultAsyncBox) Insert(object *Result) (id uint64, err error) {
	return asyncBox.AsyncBox.Insert(object)
}

// Update a single object asynchronously.
// The object must already exists or the update fails silently (without an error returned).
func (asyncBox *ResultAsyncBox) Update(object *Result) error {
	return asyncBox.AsyncBox.Update(object)
}

// Remove deletes a single object asynchronously.
func (asyncBox *ResultAsyncBox) Remove(object *Result) error {
	return asyncBox.AsyncBox.Remove(object)
}

// Query provides a way to search stored objects
//
// For example, you can find all Result which Id is either 42 or 47:
//
// box.Query(Result_.Id.In(42, 47)).Find()
type ResultQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *ResultQuery) Find() ([]*Result, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Result), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *ResultQuery) Offset(offset uint64) *ResultQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *ResultQuery) Limit(limit uint64) *ResultQuery {
	query.Query.Limit(limit)
	return query
}
